  ListNode **pHead = new ListNode*();
    addListNode(pHead,1);
    addListNode(pHead,2);
    addListNode(pHead,3);
    addListNode(pHead,4);
    addListNode(pHead,5);
    addListNode(pHead,6);
    ListNode *p = FindKthToTail(*pHead, 1);
    gh::print(p->m_nValue);

    //    char matrix[12] = {'a','b','t','g','c','f','c','s','j','d','e','h'};
    //    gh::print(hasPath(matrix, 3,4,"bfce"));
    //    gh::print(hasPath(matrix, 3,4,"abfb"));
    //    gh::print(maxProductAfterCutting_solution(8));
    //    Print1ToMaxOfDigits(3);
        ListNode **phead = new ListNode*();
        addListNode(phead,1);
        addListNode(phead,1);
        addListNode(phead,2);
        addListNode(phead,2);
        addListNode(phead,3);
        addListNode(phead,3);
        printListNode(phead);
    //    ListNode *head = newListNode(10);
    //    addListNode(head, newListNode(1));
    //    addListNode(head, newListNode(1));
    //    addListNode(head, newListNode(2));
    //    addListNode(head, newListNode(2));
    //    addListNode(head, newListNode(3));
    //    addListNode(head, newListNode(4));
    //    printListNode(head);

    //    ListNode *pToBeDelete = head->m_pNext;
    //    DeleteNode(head, pToBeDelete);
    //    *phead = head;
        DeleteDuplication(phead);
        printListNode(phead);

ListNode *head = newListNode(1);
    addListNode(head, newListNode(2));
    addListNode(head, newListNode(3));
    addListNode(head, newListNode(4));
    addListNode(head, newListNode(5));
    addListNode(head, newListNode(6));
    addListNode(head, newListNode(7));
    ListNode *pNode4 = nullptr;
    ListNode *p = head;
    while (p != nullptr) {
        if (p->m_nValue == 4) {
            pNode4 = p;
            break;
        }
        p = p->m_pNext;
    }
    p = head;
    while (p->m_pNext!= nullptr) {
        p = p->m_pNext;
    }
    p->m_pNext = pNode4;

//    while (head != nullptr) {
//        gh::print(head->m_nValue);
//        head = head->m_pNext;
//    }
    p = EntryNodeLoop(head);
    gh::print(p->m_nValue);

    int numbers1[4] = {1,3,5,7};
        int numbers2[4] = {2,4,5,8};
        ListNode* pHead1 = newListNode(numbers1, 4);
        ListNode* pHead2 = newListNode(numbers2, 4);
        ListNode *pHead = mergeListNodeByRecursion(pHead1, pHead2);
        while (pHead!= nullptr) {
            gh::print(pHead->m_nValue);
            pHead = pHead->m_pNext;
        }
        err_msg("asd");


         int numbers[4][4] = {{1,2,3,4},{5,6,7,8}, {9,10,11,12}, {13,14,15,16}};
            int **nums = new int*[4];
            for (int i = 0; i < 4; ++i)
                nums[i] = new int[4];
            int k = 1;
            for (int i = 0; i < 4; ++i)
                for (int j = 0; j < 4; ++j) {
                    nums[i][j] = k++;
                }

            k = 1;
            int **nums2 = new int*[5];
            for (int i = 0; i < 3; ++i)
                nums2[i] = new int[5];

            for (int i = 0; i < 3; ++i)
                for (int j = 0; j < 5; ++j) {
                    nums2[i][j] = k++;
                }

            PrintMatrixClockwisely(nums2, 5, 3);
            printf("\n");
            PrintMatrixClockwisely(nums, 4, 4);
            //31
               int pPush[5] = {1,2,3,4,5};
               int pPop[5] = {4,5,5,1,2};
               gh::print(isStackOrder(pPush,pPop,5));
